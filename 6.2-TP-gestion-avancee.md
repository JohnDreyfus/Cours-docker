## TP pratique : Application avec base de données

### Objectif

Déployer une application complète avec :
- Base de données PostgreSQL avec persistence
- API Node.js connectée à la base
- Exposition des services sur des ports spécifiques

### Étape 1 : Préparation de l'environnement

Créer un dossier pour le projet et la structure nécessaire :

```bash
mkdir tp-docker-app
cd tp-docker-app
mkdir app
```

Créer le réseau et le volume :

```bash
# Créer un réseau dédié
docker network create app-net

# Vérifier qu'il a bien été créé
docker network ls

# Créer un volume pour la base de données
docker volume create pgdata

# Vérifier qu'il a bien été créé
docker volume ls
```

### Étape 2 : Base de données PostgreSQL

Lancer le conteneur PostgreSQL :

```bash
docker run -d \
  --name postgres-db \
  --network app-net \
  -e POSTGRES_USER=appuser \
  -e POSTGRES_PASSWORD=apppassword \
  -e POSTGRES_DB=appdb \
  -v pgdata:/var/lib/postgresql/data \
  postgres:17
  
  
# Vérifier qu'il a bien été créé et qu'il tourne
docker ps
```

**Explication des paramètres :**
- `--network app-net` : Connecte le conteneur au réseau personnalisé
- `-e` : Définit les variables d'environnement pour la configuration PostgreSQL
- `-v pgdata:/var/lib/postgresql/data` : Monte le volume pour persister les données

### Étape 3 : Application Node.js

#### Fichier `app/package.json`

```json
{
  "name": "docker-api-example",
  "version": "1.0.0",
  "description": "API Node.js avec PostgreSQL",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.0"
  }
}
```

#### Fichier `app/server.js`

```javascript
const express = require('express');
const { Pool } = require('pg');

const app = express();
const port = 3000;

// Configuration de la connexion PostgreSQL
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

// Middleware pour parser le JSON
app.use(express.json());

// Route de test
app.get('/', (req, res) => {
  res.json({ message: 'API fonctionnelle', status: 'ok' });
});

// Route pour vérifier la connexion à la base
app.get('/health', async (req, res) => {
  try {
    const result = await pool.query('SELECT NOW()');
    res.json({ 
      database: 'connected', 
      timestamp: result.rows[0].now 
    });
  } catch (err) {
    res.status(500).json({ 
      database: 'error', 
      message: err.message 
    });
  }
});

// Initialisation de la table au démarrage
async function initDatabase() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('Table users créée ou déjà existante');
  } catch (err) {
    console.error('Erreur lors de l\'initialisation de la base:', err);
  }
}

// Route pour créer un utilisateur
app.post('/users', async (req, res) => {
  const { name, email } = req.body;
  try {
    const result = await pool.query(
      'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
      [name, email]
    );
    res.status(201).json(result.rows[0]);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// Route pour lister les utilisateurs
app.get('/users', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM users ORDER BY id');
    res.json(result.rows);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Démarrage du serveur
app.listen(port, async () => {
  console.log(`Serveur démarré sur le port ${port}`);
  await initDatabase();
});
```

#### Fichier `app/Dockerfile`

```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copier les fichiers de dépendances
COPY package.json ./

# Installer les dépendances
RUN npm install --production

# Copier le code source
COPY server.js ./

EXPOSE 3000

CMD ["node", "server.js"]
```

#### Fichier `app/.dockerignore`

```
node_modules
npm-debug.log
.git
.gitignore
```

### Étape 4 : Construction et lancement de l'application

Se positionner dans le dossier `app` et construire l'image :

```bash
cd app
docker build -t mon-api:1.0 .

# Verifier que l'image a bien été build
docker images
```

Lancer le conteneur de l'application :

```bash
docker run -d \
  --name api \
  --network app-net \
  -e DATABASE_URL=postgresql://appuser:apppassword@postgres-db:5432/appdb \
  -e NODE_ENV=production \
  -p 3000:3000 \
  mon-api:1.0
```

**Explication :**
- `DATABASE_URL` utilise le nom du conteneur `postgres-db` comme hostname (résolution DNS interne Docker)
- `-p 3000:3000` : Expose le port 3000 du conteneur sur le port 3000 de l'hôte

### Étape 5 : Vérification et tests

Vérifier que les conteneurs sont actifs :

```bash
docker ps
```

Consulter les logs :

```bash
docker logs postgres-db
docker logs api
```

Tester l'API :

```bash
# Test de base
curl http://localhost:3000

# Vérification de la connexion à la base
curl http://localhost:3000/health

# Créer un utilisateur
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice Dupont","email":"alice@example.com"}'

# Lister les utilisateurs
curl http://localhost:3000/users
```

Inspecter le réseau pour voir les conteneurs connectés :

```bash
docker network inspect app-net
```

### Étape 6 : Test de persistence des données

Arrêter et supprimer le conteneur PostgreSQL :

```bash
docker rm -f postgres-db
```

Relancer PostgreSQL avec le même volume :

```bash
docker run -d \
  --name postgres-db \
  --network app-net \
  -e POSTGRES_USER=appuser \
  -e POSTGRES_PASSWORD=apppassword \
  -e POSTGRES_DB=appdb \
  -v pgdata:/var/lib/postgresql/data \
  postgres:17
```

Attendre quelques secondes que la base redémarre, puis vérifier que les données sont toujours présentes :

```bash
curl http://localhost:3000/users
```

Les utilisateurs créés précédemment sont toujours présents grâce à la persistence via le volume.

### Étape 7 : Nettoyage

Arrêter et supprimer les conteneurs :

```bash
docker rm -f api postgres-db
```

Supprimer le réseau :

```bash
docker network rm app-net
```

Supprimer le volume (attention : suppression définitive des données) :

```bash
docker volume rm pgdata
```

### Points clés à retenir

**Volumes :** Permettent de persister les données au-delà du cycle de vie des conteneurs.

**Réseaux personnalisés :** Facilitent la communication entre conteneurs via des noms DNS.

**Variables d'environnement :** Configurent les applications sans modifier le code source.

**Exposition de ports :** Le mapping `-p` permet d'accéder aux services depuis l'hôte.